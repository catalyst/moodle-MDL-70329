<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Class to print a view of the question bank.
 *
 * @package   core_question
 * @copyright 1999 onwards Martin Dougiamas and others {@link http://moodle.com}
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace core_question\local\bank;

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/question/editlib.php');
use core_plugin_manager;
use qbank_columnsortorder\column_manager;
use qbank_editquestion\editquestion_helper;
use qbank_managecategories\helper;

/**
 * This class prints a view of the question bank.
 *
 * including
 *  + Some controls to allow users to to select what is displayed.
 *  + A list of questions as a table.
 *  + Further controls to do things with the questions.
 *
 * This class gives a basic view, and provides plenty of hooks where subclasses
 * can override parts of the display.
 *
 * The list of questions presented as a table is generated by creating a list of
 * core_question\bank\column objects, one for each 'column' to be displayed. These
 * manage
 *  + outputting the contents of that column, given a $question object, but also
 *  + generating the right fragments of SQL to ensure the necessary data is present,
 *    and sorted in the right order.
 *  + outputting table headers.
 *
 * @copyright 2009 Tim Hunt
 * @author    2021 Safat Shahin <safatshahin@catalyst-au.net>
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class view {

    /**
     * Maximum number of sorts allowed.
     */
    const MAX_SORTS = 3;

    /**
     * @var \moodle_url base URL for the current page. Used as the
     * basis for making URLs for actions that reload the page.
     */
    protected $baseurl;

    /**
     * @var \moodle_url used as a basis for URLs that edit a question.
     */
    protected $editquestionurl;

    /**
     * @var \core_question\local\bank\question_edit_contexts
     */
    public $contexts;

    /**
     * @var object|\cm_info|null if we are in a module context, the cm.
     */
    public $cm;

    /**
     * @var object the course we are within.
     */
    public $course;

    /**
     * @var \core_question\local\bank\column_base[] these are all the 'columns' that are
     * part of the display. Array keys are the class name.
     */
    protected $requiredcolumns;

    /**
     * @var \core_question\local\bank\column_base[] these are the 'columns' that are
     * actually displayed as a column, in order. Array keys are the class name.
     */
    protected $visiblecolumns;

    /**
     * @var \core_question\local\bank\column_base[] these are the 'columns' that are
     * common to the question bank.
     */
    protected $corequestionbankcolumns;

    /**
     * @var \core_question\local\bank\column_base[] these are the 'columns' that are
     * actually displayed as an additional row (e.g. question text), in order.
     * Array keys are the class name.
     */
    protected $extrarows;

    /**
     * @var array list of column class names for which columns to sort on.
     */
    protected $sort;

    /**
     * @var int|null id of the a question to highlight in the list (if present).
     */
    protected $lastchangedid;

    /**
     * @var string SQL to count the number of questions matching the current
     * search conditions.
     */
    protected $countsql;

    /**
     * @var string SQL to actually load the question data to display.
     */
    protected $loadsql;

    /**
     * @var array params used by $countsql and $loadsql (which currently must be the same).
     */
    protected $sqlparams;

    /**
     * @var condition[] search conditions.
     */
    protected $searchconditions = [];

    /**
     * @var string url of the new question page.
     */
    public $returnurl;

    /**
     * @var array $bulkactions to identify the bulk actions for the api.
     */
    public $bulkactions = [];

    /**
     * @var int|null Number of questions.
     */
    protected $totalcount = null;

    /**
     * @var array Number of questions.
     */
    protected $pagevars = [];

    /**
     * @var array $plugins all the qbank plugin objects.
     */
    protected $plugins = [];

    /**
     * @var string $component the component the api is used from.
     */
    public $component = 'core_question';

    /**
     * @var string $callback name of the callback for the api call via filter js.
     */
    public $callback = 'question_data';

    /**
     * @var array $extraparams extra parameters for the extended apis.
     */
    public $extraparams = [];

    /**
     * Constructor for view.
     *
     * @param \core_question\local\bank\question_edit_contexts $contexts
     * @param \moodle_url $pageurl
     * @param object $course course settings
     * @param null $cm (optional) activity settings.
     * @param array $params the parameters required to initialize the api.
     * @param array $extraparams any extra parameters need to initialized if the api is extended, it will be passed to js.
     */
    public function __construct($contexts, $pageurl, $course, $cm = null, $params = [], $extraparams = []) {
        $this->contexts = $contexts;
        $this->baseurl = $pageurl;
        $this->course = $course;
        $this->cm = $cm;
        $this->extraparams = $extraparams;

        // Create the url of the new question page to forward to.
        $this->returnurl = $pageurl->out_as_local_url(false);
        $this->editquestionurl = new \moodle_url('/question/bank/editquestion/question.php', ['returnurl' => $this->returnurl]);
        if ($this->cm !== null) {
            $this->editquestionurl->param('cmid', $this->cm->id);
        } else {
            $this->editquestionurl->param('courseid', $this->course->id);
        }

        $this->lastchangedid = optional_param('lastchanged', 0, PARAM_INT);

        // Possibly the heading part can be removed.
        $this->plugins = \core_component::get_plugin_list_with_class('qbank', 'plugin_feature', 'plugin_feature.php');
        $this->init_columns($this->wanted_columns(), $this->heading_column());
        $this->init_sort();
        $this->init_bulk_actions();
        $this->set_pagevars($params);
    }

    /**
     * Set the extra params for the extended apis.
     *
     * @param $extraparams
     * @return void
     */
    public function set_extra_params($extraparams): void {
        if (!empty($extraparams)) {
            $this->extraparams = $extraparams;
        }
    }

    /**
     * Initialize bulk actions.
     */
    protected function init_bulk_actions(): void {
        $plugins = \core_component::get_plugin_list_with_class('qbank', 'plugin_feature', 'plugin_feature.php');
        foreach ($plugins as $componentname => $plugin) {
            $pluginentrypoint = new $plugin();
            $pluginentrypointobject = $pluginentrypoint->get_bulk_actions();
            // Don't need the plugins without bulk actions.
            if ($pluginentrypointobject === null) {
                unset($plugins[$componentname]);
                continue;
            }
            if (!\core\plugininfo\qbank::is_plugin_enabled($componentname)) {
                unset($plugins[$componentname]);
                continue;
            }
            $this->bulkactions[$pluginentrypointobject->get_bulk_action_key()] = [
                'title' => $pluginentrypointobject->get_bulk_action_title(),
                'url' => $pluginentrypointobject->get_bulk_action_url(),
                'capabilities' => $pluginentrypointobject->get_bulk_action_capabilities()
            ];
        }
    }

    /**
     * Initialize search conditions from plugins
     * local_*_get_question_bank_search_conditions() must return an array of
     * \core_question\bank\search\condition objects.
     * @todo Final deprecation on Moodle 4.4 MDL-72438
     */
    protected function init_search_conditions(): void {
        debugging('Function init_search_conditions() has been deprecated,
         please create a qbank plugin and implement a filter object instead.', DEBUG_DEVELOPER);
        $searchplugins = get_plugin_list_with_function('local', 'get_question_bank_search_conditions');
        foreach ($searchplugins as $component => $function) {
            foreach ($function($this) as $searchobject) {
                $this->add_searchcondition($searchobject);
            }
        }
    }

    /**
     * Get class for each question bank columns.
     *
     * @return array
     */
    protected function get_class_for_columns(): array {
        $this->corequestionbankcolumns = [
            'checkbox_column',
            'question_type_column',
            'question_name_idnumber_tags_column',
            'edit_menu_column',
            'edit_action_column',
            'copy_action_column',
            'tags_action_column',
            'preview_action_column',
            'history_action_column',
            'delete_action_column',
            'export_xml_action_column',
            'question_status_column',
            'version_number_column',
            'creator_name_column',
            'comment_count_column',
            'question_text_row',
        ];
        $questionbankclasscolumns = [];
        foreach ($this->corequestionbankcolumns as $fullname) {
            $shortname = $fullname;
            if (class_exists('core_question\\local\\bank\\' . $fullname)) {
                $fullname = 'core_question\\local\\bank\\' . $fullname;
                $questionbankclasscolumns[$shortname] = new $fullname($this);
            } else {
                $questionbankclasscolumns[$shortname] = '';
            }
        }
        return $questionbankclasscolumns;
    }

    /**
     * Get the list of qbank plugins with available objects for features.
     *
     * @return array
     */
    protected function get_question_bank_plugins(): array {
        $newpluginclasscolumns = [];
        $questionbankclasscolumns = $this->get_class_for_columns();

        $plugins = $this->plugins;
        foreach ($plugins as $componentname => $plugin) {
            $pluginentrypointobject = new $plugin();
            $plugincolumnobjects = $pluginentrypointobject->get_question_columns($this);
            // Don't need the plugins without column objects.
            if (empty($plugincolumnobjects)) {
                unset($plugins[$componentname]);
                continue;
            }
            foreach ($plugincolumnobjects as $columnobject) {
                $columnname = $columnobject->get_column_name();
                foreach ($this->corequestionbankcolumns as $key => $corequestionbankcolumn) {
                    if (!\core\plugininfo\qbank::is_plugin_enabled($componentname)) {
                        unset($questionbankclasscolumns[$columnname]);
                        continue;
                    }
                    // Check if it has custom preference selector to view/hide.
                    if ($columnobject->has_preference()) {
                        if (!$columnobject->get_preference()) {
                            continue;
                        }
                    }
                    if ($corequestionbankcolumn === $columnname) {
                        $questionbankclasscolumns[$columnname] = $columnobject;
                    } else {
                        // Any community plugin for column/action.
                        $newpluginclasscolumns[$columnname] = $columnobject;
                    }
                }
            }
        }

        // New plugins added at the end of the array, will change in sorting feature.
        foreach ($newpluginclasscolumns as $key => $newpluginclasscolumn) {
            $questionbankclasscolumns[$key] = $newpluginclasscolumn;
        }

        // Check if qbank_columnsortorder is enabled.
        if (array_key_exists('columnsortorder', core_plugin_manager::instance()->get_enabled_plugins('qbank'))) {
            $columnorder = new column_manager();
            $questionbankclasscolumns = $columnorder->get_sorted_columns($questionbankclasscolumns);
        }

        // Mitigate the error in case of any regression.
        foreach ($questionbankclasscolumns as $shortname => $questionbankclasscolumn) {
            if (empty($questionbankclasscolumn)) {
                unset($questionbankclasscolumns[$shortname]);
            }
        }

        return $questionbankclasscolumns;
    }

    /**
     * Loads all the available columns.
     *
     * @return array
     */
    protected function wanted_columns(): array {
        $this->requiredcolumns = [];
        $questionbankcolumns = $this->get_question_bank_plugins();
        foreach ($questionbankcolumns as $classobject) {
            if (empty($classobject)) {
                continue;
            }
            $this->requiredcolumns[$classobject->get_column_name()] = $classobject;
        }

        return $this->requiredcolumns;
    }


    /**
     * Check a column object from its name and get the object for sort.
     *
     * @param string $columnname
     */
    protected function get_column_type($columnname) {
        if (empty($this->requiredcolumns[$columnname])) {
            $this->requiredcolumns[$columnname] = new $columnname($this);
        }
    }

    /**
     * Specify the column heading
     *
     * @return string Column name for the heading
     */
    protected function heading_column(): string {
        return 'qbank_viewquestionname\viewquestionname_column_helper';
    }

    /**
     * Initializing table columns
     *
     * @param array $wanted Collection of column names
     * @param string $heading The name of column that is set as heading
     */
    protected function init_columns($wanted, $heading = ''): void {
        // If we are using the edit menu column, allow it to absorb all the actions.
        foreach ($wanted as $column) {
            if ($column instanceof edit_menu_column) {
                $wanted = $column->claim_menuable_columns($wanted);
                break;
            }
        }

        // Now split columns into real columns and rows.
        $this->visiblecolumns = [];
        $this->extrarows = [];
        foreach ($wanted as $column) {
            if ($column->is_extra_row()) {
                $this->extrarows[$column->get_column_name()] = $column;
            } else {
                $this->visiblecolumns[$column->get_column_name()] = $column;
            }
        }

        if (array_key_exists($heading, $this->requiredcolumns)) {
            $this->requiredcolumns[$heading]->set_as_heading();
        }
    }

    /**
     * Checks if the column included in the output.
     *
     * @param string $colname a column internal name.
     * @return bool is this column included in the output?
     */
    public function has_column($colname): bool {
        return isset($this->visiblecolumns[$colname]);
    }

    /**
     * Get the count of the columns.
     *
     * @return int The number of columns in the table.
     */
    public function get_column_count(): int {
        return count($this->visiblecolumns);
    }

    /**
     * Get course id.
     * @return mixed
     */
    public function get_courseid() {
        return $this->course->id;
    }

    /**
     * Initialise sorting.
     */
    protected function init_sort(): void {
        $this->init_sort_from_params();
        if (empty($this->sort)) {
            $this->sort = $this->default_sort();
        }
    }

    /**
     * Deal with a sort name of the form columnname, or colname_subsort by
     * breaking it up, validating the bits that are present, and returning them.
     * If there is no subsort, then $subsort is returned as ''.
     *
     * @param string $sort the sort parameter to process.
     * @return array [$colname, $subsort].
     */
    protected function parse_subsort($sort): array {
        // Do the parsing.
        if (strpos($sort, '-') !== false) {
            list($colname, $subsort) = explode('-', $sort, 2);
        } else {
            $colname = $sort;
            $subsort = '';
        }
        // Validate the column name.
        $this->get_column_type($colname);
        $column = $this->requiredcolumns[$colname];
        if (!isset($column) || !$column->is_sortable()) {
            for ($i = 1; $i <= self::MAX_SORTS; $i++) {
                $this->baseurl->remove_params('qbs' . $i);
            }
            throw new \moodle_exception('unknownsortcolumn', '', $link = $this->baseurl->out(), $colname);
        }
        // Validate the subsort, if present.
        if ($subsort) {
            $subsorts = $column->is_sortable();
            if (!is_array($subsorts) || !isset($subsorts[$subsort])) {
                throw new \moodle_exception('unknownsortcolumn', '', $link = $this->baseurl->out(), $sort);
            }
        }
        return [$colname, $subsort];
    }

    /**
     * Initialise sort from parameters.
     */
    protected function init_sort_from_params(): void {
        $this->sort = [];
        for ($i = 1; $i <= self::MAX_SORTS; $i++) {
            if (!$sort = optional_param('qbs' . $i, '', PARAM_TEXT)) {
                if (!$sort = $this->get_pagevars('qbs' . $i)) {
                    break;
                }
            }
            // Work out the appropriate order.
            $order = 1;
            if ($sort[0] == '-') {
                $order = -1;
                $sort = substr($sort, 1);
                if (!$sort) {
                    break;
                }
            }
            // Deal with subsorts.
            list($colname) = $this->parse_subsort($sort);
            $this->get_column_type($colname);
            $this->sort[$sort] = $order;
        }
    }

    /**
     * Sort to parameters.
     *
     * @param array $sorts
     * @return array
     */
    protected function sort_to_params($sorts): array {
        $params = [];
        $i = 0;
        foreach ($sorts as $sort => $order) {
            $i += 1;
            if ($order < 0) {
                $sort = '-' . $sort;
            }
            $params['qbs' . $i] = $sort;
        }
        return $params;
    }

    /**
     * Default sort for question data.
     * @return int[]
     */
    protected function default_sort(): array {
        $defaultsort = [];
        if (class_exists('\\qbank_viewquestiontype\\question_type_column')) {
            $sort = 'qbank_viewquestiontype\question_type_column';
        }
        $defaultsort[$sort] = 1;
        if (class_exists('\\qbank_viewquestionname\\question_name_idnumber_tags_column')) {
            $sort = 'qbank_viewquestionname\question_name_idnumber_tags_column';
        }
        $defaultsort[$sort . '-name'] = 1;

        return $defaultsort;
    }

    /**
     * Gets the primary sort order according to the default sort.
     *
     * @param string $sort a column or column_subsort name.
     * @return int the current sort order for this column -1, 0, 1
     */
    public function get_primary_sort_order($sort): int {
        $order = reset($this->sort);
        $primarysort = key($this->sort);
        if ($sort == $primarysort) {
            return $order;
        }

        return 0;
    }

    /**
     * Get a URL to redisplay the page with a new sort for the question bank.
     *
     * @param string $sort the column, or column_subsort to sort on.
     * @param bool $newsortreverse whether to sort in reverse order.
     * @return string The new URL.
     */
    public function new_sort_url($sort, $newsortreverse): string {
        if ($newsortreverse) {
            $order = -1;
        } else {
            $order = 1;
        }
        // Tricky code to add the new sort at the start, removing it from where it was before, if it was present.
        $newsort = array_reverse($this->sort);
        if (isset($newsort[$sort])) {
            unset($newsort[$sort]);
        }
        $newsort[$sort] = $order;
        $newsort = array_reverse($newsort);
        if (count($newsort) > self::MAX_SORTS) {
            $newsort = array_slice($newsort, 0, self::MAX_SORTS, true);
        }
        return $this->baseurl->out(true, $this->sort_to_params($newsort));
    }

    /**
     * Create the SQL query to retrieve the indicated questions, based on
     * \core_question\local\bank\condition filters.
     */
    protected function build_query(): void {
        // Get the required tables and fields.
        $joins = [];
        $fields = ['qv.status', 'qc.id as categoryid', 'qv.version', 'qv.id as versionid', 'qbe.id as questionbankentryid'];
        if (!empty($this->requiredcolumns)) {
            foreach ($this->requiredcolumns as $column) {
                $extrajoins = $column->get_extra_joins();
                foreach ($extrajoins as $prefix => $join) {
                    if (isset($joins[$prefix]) && $joins[$prefix] != $join) {
                        throw new \coding_exception('Join ' . $join . ' conflicts with previous join ' . $joins[$prefix]);
                    }
                    $joins[$prefix] = $join;
                }
                $fields = array_merge($fields, $column->get_required_fields());
            }
        }
        $fields = array_unique($fields);

        // Build the order by clause.
        $sorts = [];
        foreach ($this->sort as $sort => $order) {
            list($colname, $subsort) = $this->parse_subsort($sort);
            $sorts[] = $this->requiredcolumns[$colname]->sort_expression($order < 0, $subsort);
        }

        // Build the where clause.
        $latestversion = 'qv.version = (SELECT MAX(v.version)
                                          FROM {question_versions} v
                                          JOIN {question_bank_entries} be
                                            ON be.id = v.questionbankentryid
                                         WHERE be.id = qbe.id)';
        $tests = ['q.parent = 0', $latestversion];
        $this->sqlparams = [];
        foreach ($this->searchconditions as $searchcondition) {
            if ($searchcondition->where()) {
                $tests[] = '((' . $searchcondition->where() .'))';
            }
            if ($searchcondition->params()) {
                $this->sqlparams = array_merge($this->sqlparams, $searchcondition->params());
            }
        }
        // Get higher level filter condition.
        $filterverb = $this->pagevars['filterverb'] ?? condition::JOINTYPE_DEFAULT;
        $equal = !($filterverb === condition::JOINTYPE_NONE);
        $whereclause = ($equal) ? ' WHERE ' : ' WHERE NOT ';
        // Build the SQL.
        $sql = ' FROM {question} q ' . implode(' ', $joins);
        $sql .= $whereclause . implode(' AND ', $tests);
        $this->countsql = 'SELECT count(1)' . $sql;
        $this->loadsql = 'SELECT ' . implode(', ', $fields) . $sql . ' ORDER BY ' . implode(', ', $sorts);
    }

    /**
     * Get the number of questions.
     *
     * @return int
     */
    public function get_question_count(): int {
        global $DB;
        if (is_null($this->totalcount)) {
            $this->totalcount = $DB->count_records_sql($this->countsql, $this->sqlparams);
        }
        return $this->totalcount;
    }

    /**
     * Load the questions we need to display.
     *
     * @return \moodle_recordset questionid => data about each question.
     */
    protected function load_page_questions(): \moodle_recordset {
        global $DB;
        $questions = $DB->get_recordset_sql($this->loadsql, $this->sqlparams,
            (int)$this->pagevars['qpage'] * (int)$this->pagevars['qperpage'], $this->pagevars['qperpage']);
        if (empty($questions)) {
            $questions->close();
            // No questions on this page. Reset to page 0.
            $questions = $DB->get_recordset_sql($this->loadsql, $this->sqlparams, 0, $this->pagevars['qperpage']);
        }
        return $questions;
    }

    /**
     * Returns the base url.
     *
     * @return \moodle_url
     */
    public function base_url(): \moodle_url {
        return $this->baseurl;
    }

    /**
     * Get the URL for editing a question as a moodle url.
     *
     * @param int $questionid the question id.
     * @return \moodle_url the URL, HTML-escaped.
     */
    public function edit_question_moodle_url($questionid) {
        return new \moodle_url($this->editquestionurl, ['id' => $questionid]);
    }

    /**
     * Get the URL for editing a question as a HTML-escaped string.
     *
     * @param int $questionid the question id.
     * @return string the URL, HTML-escaped.
     */
    public function edit_question_url($questionid) {
        return $this->edit_question_moodle_url($questionid)->out();
    }

    /**
     * Get the URL for duplicating a question as a moodle url.
     *
     * @param int $questionid the question id.
     * @return \moodle_url the URL.
     */
    public function copy_question_moodle_url($questionid) {
        return new \moodle_url($this->editquestionurl, ['id' => $questionid, 'makecopy' => 1]);
    }

    /**
     * Get the URL for duplicating a given question.
     * @param int $questionid the question id.
     * @return string the URL, HTML-escaped.
     */
    public function copy_question_url($questionid) {
        return $this->copy_question_moodle_url($questionid)->out();
    }

    /**
     * Get the context we are displaying the question bank for.
     * @return \context context object.
     */
    public function get_most_specific_context(): \context {
        return $this->contexts->lowest();
    }

    /**
     * Get the URL to preview a question.
     * @param \stdClass $questiondata the data defining the question.
     * @return \moodle_url the URL.
     * @deprecated since Moodle 4.0
     * @see \qbank_previewquestion\helper::question_preview_url()
     * @todo Final deprecation on Moodle 4.4 MDL-72438
     */
    public function preview_question_url($questiondata) {
        debugging('Function preview_question_url() has been deprecated and moved to qbank_previewquestion plugin,
         please use qbank_previewquestion\helper::question_preview_url() instead.', DEBUG_DEVELOPER);
        return question_preview_url($questiondata->id, null, null, null, null,
                $this->get_most_specific_context());
    }

    /**
     * @param string|null $field
     * @return array|null
     */
    public function get_pagevars(string $field = null) {
        if (is_null($field)) {
            return $this->pagevars;
        } else {
            return $this->pagevars[$field] ?? null;
        }
    }

    /**
     * @param $pagevars
     * @param string|null $field
     * @return $this
     */
    public function set_pagevars($pagevars, string $field = null) {
        if (is_null($field)) {
            $this->pagevars = $pagevars;
        } else {
            $this->pagevars[$field] = $pagevars;
        }
        return $this;
    }

    /**
     * Shows the question bank interface.
     */
    public function display(): void {
        echo \html_writer::start_div('questionbankwindow boxwidthwide boxaligncenter');
        // Show the filters and search options.
        $this->wanted_filters();
        // Continues with list of questions.
        $this->display_question_list();
        echo \html_writer::end_div();

    }

    /**
     * The filters for the question bank.
     */
    public function wanted_filters(): void {
        global $PAGE;
        list(, $contextid) = explode(',', $this->pagevars['cat']);
        $catcontext = \context::instance_by_id($contextid);
        // Category selection form.
        $this->display_question_bank_header();
        // Add search conditions.
        $this->add_standard_searchcondition();
        // Render the question bank filters.
        $additionalparams = [
            'perpage' => $this->pagevars['qperpage'],
        ];
        echo $PAGE->get_renderer('core_question', 'bank')->render_questionbank_filter(
            $catcontext, $this->searchconditions, $additionalparams, $this->component, $this->callback, $this->extraparams);
    }

    /**
     * Print the text if category id not available.
     *
     * @todo Final deprecation of this function in moodle 4.5
     */
    protected function print_choose_category_message(): void {
        debugging('Function print_choose_category_message() is deprecated,
         all the features for this method is currently handles by the qbank filter api,
         please have a look at question/bank/managecategories/classes/category_confition.php for more information.', DEBUG_DEVELOPER);
        echo \html_writer::start_tag('p', ['style' => "\"text-align:center;\""]);
        echo \html_writer::tag('b', get_string('selectcategoryabove', 'question'));
        echo \html_writer::end_tag('p');
    }

    /**
     * Gets current selected category.
     * @param string $categoryandcontext
     * @return false|mixed|\stdClass
     *
     * @todo Final deprecation of this function in moodle 4.5
     */
    protected function get_current_category($categoryandcontext) {
        debugging('Function get_current_category() is deprecated,
         all the features for this method is currently handles by the qbank filter api,
         please have a look at question/bank/managecategories/classes/category_confition.php for more information.', DEBUG_DEVELOPER);
        global $DB, $OUTPUT;
        list($categoryid, $contextid) = explode(',', $categoryandcontext);
        if (!$categoryid) {
            $this->print_choose_category_message();
            return false;
        }

        if (!$category = $DB->get_record('question_categories',
            ['id' => $categoryid, 'contextid' => $contextid])) {
            echo $OUTPUT->box_start('generalbox questionbank');
            echo $OUTPUT->notification('Category not found!');
            echo $OUTPUT->box_end();
            return false;
        }

        return $category;
    }

    /**
     * Display the form with options for which questions are displayed and how they are displayed.
     *
     * @param bool $showquestiontext Display the text of the question within the list.
     * @deprecated since Moodle 4.0 MDL-72321 - please do not use this function any more.
     * @todo Final deprecation on Moodle 4.1 MDL-72572
     */
    protected function display_options_form($showquestiontext): void {
        debugging('Function display_options_form() is deprecated, this method has been replaced with mustaches in filters,
            please use filtering objects', DEBUG_DEVELOPER);
        global $PAGE;

        // The html will be refactored in the filter feature implementation.
        echo \html_writer::start_tag('form', ['method' => 'get',
                'action' => new \moodle_url($this->baseurl), 'id' => 'displayoptions']);
        echo \html_writer::start_div();

        $excludes = ['recurse', 'showhidden', 'qbshowtext'];
        // If the URL contains any tags then we need to prevent them
        // being added to the form as hidden elements because the tags
        // are managed separately.
        if ($this->baseurl->param('qtagids[0]')) {
            $index = 0;
            while ($this->baseurl->param("qtagids[{$index}]")) {
                $excludes[] = "qtagids[{$index}]";
                $index++;
            }
        }
        echo \html_writer::input_hidden_params($this->baseurl, $excludes);

        $advancedsearch = [];

        foreach ($this->searchconditions as $searchcondition) {
            if ($searchcondition->display_options_adv()) {
                $advancedsearch[] = $searchcondition;
            }
        }
        if (!empty($advancedsearch)) {
            $this->display_advanced_search_form($advancedsearch);
        }

        $go = \html_writer::empty_tag('input', ['type' => 'submit', 'value' => get_string('go')]);
        echo \html_writer::tag('noscript', \html_writer::div($go), ['class' => 'inline']);
        echo \html_writer::end_div();
        echo \html_writer::end_tag('form');
        $PAGE->requires->yui_module('moodle-question-searchform', 'M.question.searchform.init');
    }

    /**
     * Print the "advanced" UI elements for the form to select which questions. Hidden by default.
     *
     * @param array $advancedsearch
     * @deprecated since Moodle 4.0 MDL-72321 - please do not use this function any more.
     * @todo Final deprecation on Moodle 4.1 MDL-72572
     */
    protected function display_advanced_search_form($advancedsearch): void {
        debugging('Function display_advanced_search_form() is deprecated, this method has been replaced with mustaches in filters,
            please use filtering objects', DEBUG_DEVELOPER);
        print_collapsible_region_start('', 'advancedsearch',
                get_string('advancedsearchoptions', 'question'),
                'question_bank_advanced_search');
        foreach ($advancedsearch as $searchcondition) {
            echo $searchcondition->display_options_adv();
        }
        print_collapsible_region_end();
    }

    /**
     * Display the checkbox UI for toggling the display of the question text in the list.
     * @param bool $showquestiontext the current or default value for whether to display the text.
     * @todo Final deprecation on Moodle 4.1 MDL-72572
     */
    protected function display_showtext_checkbox($showquestiontext): void {
        debugging('Function display_showtext_checkbox() is deprecated, please use filtering objects', DEBUG_DEVELOPER);
        global $PAGE;
        $displaydata = [
                'checked' => $showquestiontext
        ];
        if (class_exists('qbank_viewquestiontext\\question_text_row')) {
            if (\core\plugininfo\qbank::is_plugin_enabled('qbank_viewquestiontext')) {
                echo $PAGE->get_renderer('core_question', 'bank')->render_showtext_checkbox($displaydata);
            }
        }
    }

    /**
     * Display the header element for the question bank.
     */
    protected function display_question_bank_header(): void {
        global $OUTPUT;
        echo $OUTPUT->heading(get_string('questionbank', 'question'), 2);
    }

    /**
     * Create a new question form.
     *
     * @param false|mixed|\stdClass $category
     * @param bool $canadd
     */
    protected function create_new_question_form($category, $canadd): void {
        if (\core\plugininfo\qbank::is_plugin_enabled('qbank_editquestion')) {
            echo editquestion_helper::create_new_question_button($category->id,
                    $this->requiredcolumns['edit_action_column']->editquestionurl->params(), $canadd);
        }
    }

    /**
     * Prints the table of questions in a category with interactions
     */
    protected function display_question_list(): void {
        // This function can be moderately slow with large question counts and may time out.
        // We probably do not want to raise it to unlimited, so randomly picking 5 minutes.
        // Note: We do not call this in the loop because quiz ob_ captures this function (see raise() PHP doc).
        \core_php_time_limit::raise(300);

        $category = \qbank_managecategories\category_condition::get_current_category($this->pagevars['cat']);

        list($categoryid, $contextid) = explode(',', $this->pagevars['cat']);
        $catcontext = \context::instance_by_id($contextid);

        $canadd = has_capability('moodle/question:add', $catcontext);

        $this->create_new_question_form($category, $canadd);

        // This html will be refactored in the bulk actions implementation.
        echo \html_writer::start_tag('form', ['action' => $this->baseurl, 'method' => 'post', 'id' => 'questionsubmit']);
        echo \html_writer::start_tag('fieldset', ['class' => 'invisiblefieldset', 'style' => "display: block;"]);
        echo \html_writer::empty_tag('input', ['type' => 'hidden', 'name' => 'sesskey', 'value' => sesskey()]);
        echo \html_writer::input_hidden_params($this->baseurl);

        echo \html_writer::start_tag('div',
            ['class' => 'categoryquestionscontainer', 'id' => 'questionscontainer']);
        echo \html_writer::end_tag('div');

        $this->display_bottom_controls($catcontext);

        echo \html_writer::end_tag('fieldset');
        echo \html_writer::end_tag('form');
    }

    /**
     * Display the top pagination bar.
     *
     * @param object $pagination
     * @todo Final deprecation on Moodle 4.4 MDL-72438
     */
    public function display_top_pagnation($pagination): void {
        debugging('Function display_top_pagnation() is deprecated, please use display_questions()
         for ajax based pagination.', DEBUG_DEVELOPER);
        global $PAGE;
        $displaydata = [
                'pagination' => $pagination
        ];
        echo $PAGE->get_renderer('core_question', 'bank')->render_question_pagination($displaydata);
    }

    /**
     * Display bottom pagination bar.
     *
     * @param string $pagination
     * @param int $totalnumber
     * @param int $perpage
     * @param \moodle_url $pageurl
     * @todo Final deprecation on Moodle 4.4 MDL-72438
     */
    public function display_bottom_pagination($pagination, $totalnumber, $perpage, $pageurl): void {
        debugging('Function display_bottom_pagination() is deprecated, please use display_questions()
         for ajax based pagination.', DEBUG_DEVELOPER);
        global $PAGE;
        $displaydata = array (
                'extraclasses' => 'pagingbottom',
                'pagination' => $pagination,
                'biggertotal' => true,
        );
        if ($totalnumber > DEFAULT_QUESTIONS_PER_PAGE) {
            $displaydata['showall'] = true;
            if ($perpage == DEFAULT_QUESTIONS_PER_PAGE) {
                $url = new \moodle_url($pageurl, array_merge($pageurl->params(),
                        ['qpage' => 0, 'qperpage' => MAXIMUM_QUESTIONS_PER_PAGE]));
                if ($totalnumber > MAXIMUM_QUESTIONS_PER_PAGE) {
                    $displaydata['totalnumber'] = MAXIMUM_QUESTIONS_PER_PAGE;
                } else {
                    $displaydata['biggertotal'] = false;
                    $displaydata['totalnumber'] = $totalnumber;
                }
            } else {
                $url = new \moodle_url($pageurl, array_merge($pageurl->params(),
                        ['qperpage' => DEFAULT_QUESTIONS_PER_PAGE]));
                $displaydata['totalnumber'] = DEFAULT_QUESTIONS_PER_PAGE;
            }
            $displaydata['showallurl'] = $url;
        }
        echo $PAGE->get_renderer('core_question', 'bank')->render_question_pagination($displaydata);
    }

    /**
     * Display the controls at the bottom of the list of questions.
     *
     * @param \context $catcontext The context of the category being displayed.
     */
    protected function display_bottom_controls(\context $catcontext): void {
        $caneditall = has_capability('moodle/question:editall', $catcontext);
        $canuseall = has_capability('moodle/question:useall', $catcontext);
        $canmoveall = has_capability('moodle/question:moveall', $catcontext);
        if ($caneditall || $canmoveall || $canuseall) {
            global $PAGE;
            $bulkactiondatas = [];
            $params = $this->base_url()->params();
            $params['returnurl'] = $this->base_url();
            foreach ($this->bulkactions as $key => $action) {
                // Check capabilities.
                $capcount = 0;
                foreach ($action['capabilities'] as $capability) {
                    if (has_capability($capability, $catcontext)) {
                        $capcount ++;
                    }
                }
                // At least one cap need to be there.
                if ($capcount === 0) {
                    unset($this->bulkactions[$key]);
                    continue;
                }
                $actiondata = new \stdClass();
                $actiondata->actionname = $action['title'];
                $actiondata->actionkey = $key;
                $actiondata->actionurl = new \moodle_url($action['url'], $params);
                $bulkactiondata[] = $actiondata;

                $bulkactiondatas ['bulkactionitems'] = $bulkactiondata;
            }
            // We dont need to show this section if none of the plugins are enabled.
            if (!empty($bulkactiondatas)) {
                echo $PAGE->get_renderer('core_question', 'bank')->render_bulk_actions_ui($bulkactiondatas);
            }
        }
    }

    /**
     * Display the questions.
     *
     * @param array $questions
     */
    public function display_questions($questions, $page = 1, $perpage = DEFAULT_QUESTIONS_PER_PAGE): void {
        global $OUTPUT;
        $pageingurl = new \moodle_url($this->base_url());
        $pagingbar = new \paging_bar($this->totalcount, $page, $perpage, $pageingurl);
        $pagingbar->pagevar = 'qpage';
        echo $OUTPUT->render($pagingbar);
        echo \html_writer::start_tag('div',
            ['class' => 'categoryquestionscontainer', 'id' => 'questionscontainer']);
        $this->print_table($questions);
        echo \html_writer::end_tag('div');
        echo $OUTPUT->render($pagingbar);
    }

    /**
     * Load the questions according to the search conditions.
     *
     * @return array
     */
    public function load_questions() {
        $this->init_sort_from_params();
        $this->build_query();
        $questionsrs = $this->load_page_questions();
        $questions = [];
        foreach ($questionsrs as $question) {
            if (!empty($question->id)) {
                $questions[$question->id] = $question;
            }
        }
        $questionsrs->close();
        foreach ($this->requiredcolumns as $name => $column) {
            $column->load_additional_data($questions);
        }
        return $questions;
    }

    /**
     * Prints the actual table with question.
     *
     * @param array $questions
     */
    protected function print_table($questions): void {
        // Start of the table.
        echo \html_writer::start_tag('table', ['id' => 'categoryquestions']);

        // Prints the table header.
        echo \html_writer::start_tag('thead');
        echo \html_writer::start_tag('tr');
        $this->print_table_headers();
        echo \html_writer::end_tag('tr');
        echo \html_writer::end_tag('thead');

        // Prints the table row or content.
        echo \html_writer::start_tag('tbody');
        $rowcount = 0;
        foreach ($questions as $question) {
            $this->print_table_row($question, $rowcount);
            $rowcount += 1;
        }
        echo \html_writer::end_tag('tbody');

        // End of the table.
        echo \html_writer::end_tag('table');
    }

    /**
     * Start of the table html.
     *
     * @deprecated since Moodle 4.0
     * @see print_table()
     * @todo Final deprecation on Moodle 4.4 MDL-72438
     */
    protected function start_table() {
        debugging('Function start_table() is deprecated, please use print_table() instead.', DEBUG_DEVELOPER);
        echo '<table id="categoryquestions" class="table table-responsive">' . "\n";
        echo "<thead>\n";
        $this->print_table_headers();
        echo "</thead>\n";
        echo "<tbody>\n";
    }

    /**
     * End of the table html.
     *
     * @deprecated since Moodle 4.0
     * @see print_table()
     * @todo Final deprecation on Moodle 4.4 MDL-72438
     */
    protected function end_table() {
        debugging('Function end_table() is deprecated, please use print_table() instead.', DEBUG_DEVELOPER);
        echo "</tbody>\n";
        echo "</table>\n";
    }

    /**
     * Print table headers from child classes.
     */
    public function print_table_headers(): void {
        foreach ($this->visiblecolumns as $column) {
            $column->display_header();
        }
    }

    /**
     * Gets the classes for the row.
     *
     * @param \stdClass $question
     * @param int $rowcount
     * @return array
     */
    protected function get_row_classes($question, $rowcount): array {
        $classes = [];
        if ($question->status === question_version_status::QUESTION_STATUS_HIDDEN) {
            $classes[] = 'dimmed_text';
        }
        if ($question->id == $this->lastchangedid) {
            $classes[] = 'highlight text-dark';
        }
        $classes[] = 'r' . ($rowcount % 2);
        return $classes;
    }

    /**
     * Prints the table row from child classes.
     *
     * @param \stdClass $question
     * @param int $rowcount
     */
    public function print_table_row($question, $rowcount): void {
        $rowclasses = implode(' ', $this->get_row_classes($question, $rowcount));
        $attributes = [];
        if ($rowclasses) {
            $attributes['class'] = $rowclasses;
        }
        echo \html_writer::start_tag('tr', $attributes);
        foreach ($this->visiblecolumns as $column) {
            $column->display($question, $rowclasses);
        }
        echo \html_writer::end_tag('tr');
        foreach ($this->extrarows as $row) {
            $row->display($question, $rowclasses);
        }
    }

    /**
     * Process actions for the selected action.
     * @deprecated since Moodle 4.0
     * @todo Final deprecation on Moodle 4.4 MDL-72438
     */
    public function process_actions(): void {
        debugging('Function process_actions() is deprecated and its code has been completely deleted.
         Please, remove the call from your code and check core_question\local\bank\bulk_action_base
          to learn more about bulk actions in qbank.', DEBUG_DEVELOPER);
        // Associated code is deleted to make sure any incorrect call doesnt not cause any data loss.
    }

    /**
     * Process actions with ui.
     * @return bool
     * @deprecated since Moodle 4.0
     * @todo Final deprecation on Moodle 4.4 MDL-72438
     */
    public function process_actions_needing_ui(): bool {
        debugging('Function process_actions_needing_ui() is deprecated and its code has been completely deleted.
         Please, remove the call from your code and check core_question\local\bank\bulk_action_base
          to learn more about bulk actions in qbank.', DEBUG_DEVELOPER);
        // Associated code is deleted to make sure any incorrect call doesnt not cause any data loss.
        return false;
    }

    /**
     * Add another search control to this view.
     * @param condition $searchcondition the condition to add.
     * @param string|null $fieldname
     */
    public function add_searchcondition(condition $searchcondition, ?string $fieldname = null): void {
        if (is_null($fieldname)) {
            $this->searchconditions[] = $searchcondition;
        } else {
            $this->searchconditions[$fieldname] = $searchcondition;
        }
    }

    /**
     * Add standard search conditions.
     * Params must be set into this object before calling this function.
     */
    public function add_standard_searchcondition(): void {
        foreach ($this->plugins as $componentname => $plugin) {
            if (\core\plugininfo\qbank::is_plugin_enabled($componentname)) {
                $pluginentrypointobject = new $plugin();
                $pluginobjects = $pluginentrypointobject->get_question_filters($this);
                foreach ($pluginobjects as $pluginobject) {
                    $this->add_searchcondition($pluginobject, $pluginobject->get_condition_key());
                }
            }
        }
    }

    /**
     * Gets visible columns.
     * @return array Visible columns.
     */
    public function get_visiblecolumns(): array {
        return $this->visiblecolumns;
    }

    /**
     * Get required columns.
     *
     * @return array Required columns.
     */
    public function get_requiredcolumns(): array {
        return $this->requiredcolumns;
    }

    /**
     * Display the questions table for the fragment/ajax.
     *
     * @return array
     */
    public function display_questions_table(): array {
        global $PAGE;
        $this->add_standard_searchcondition();
        $questions = $this->load_questions();
        $totalquestions = $this->get_question_count();
        $questionhtml = '';
        $PAGE->start_collecting_javascript_requirements();
        if ($totalquestions > 0) {
            ob_start();
            $this->display_questions($questions, $this->pagevars['qpage']);
            $questionhtml = ob_get_clean();
        }
        $jsfooter = $PAGE->requires->get_end_code();
        return [$questionhtml, $jsfooter];
    }

}
